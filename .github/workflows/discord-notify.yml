name: "üîî Discord Notifications"

on:
  push:
    branches: ["main"]
  deployment_status:

concurrency:
  group: discord-${{ github.event_name }}-${{ github.ref || github.sha }}
  cancel-in-progress: true

jobs:
  notify:
    name: "üì® Send Notification"
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    timeout-minutes: 2

    steps:
      - name: "üîî Discord Notification"
        uses: actions/github-script@v7
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        with:
          script: |
            if (!process.env.DISCORD_WEBHOOK_URL) {
              core.warning("‚ö†Ô∏è DISCORD_WEBHOOK_URL secret is not configured. Skipping notification.");
              return;
            }

            const repo = context.repo;
            const repoFullName = `${repo.owner}/${repo.repo}`;
            const repoUrl = `https://github.com/${repoFullName}`;
            const sender = context.payload.sender;

            const Colors = {
              success:  0x00D4AA,
              info:     0x6C63FF,
              warning:  0xFFB347,
              danger:   0xFF6B6B,
            };

            const truncate = (str, len = 200) => {
              if (!str) return "_No description_";
              return str.length > len ? str.substring(0, len) + "‚Ä¶" : str;
            };

            const timestamp = () => new Date().toLocaleString("id-ID", {
              timeZone: "Asia/Jakarta",
              day: "2-digit", month: "short", year: "numeric",
              hour: "2-digit", minute: "2-digit", second: "2-digit"
            });

            const branchName = (ref) => ref ? ref.replace("refs/heads/", "").replace("refs/tags/", "") : "unknown";
            const ownerAvatar = context.payload.repository?.owner?.avatar_url || "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png";

            // --- Event Logic ---
            if (context.eventName === 'deployment_status') {
              const status = context.payload.deployment_status;
              const deploy = context.payload.deployment;

              if (status.state !== 'success') {
                console.log("Deployment state is not 'success', skipping.");
                return;
              }

              const embed = {
                color: Colors.success,
                author: {
                  name: `ScoutLeads`,
                  url: repoUrl,
                  icon_url: ownerAvatar
                },
                title: `üåê Deploy Berhasil`,
                url: status.target_url,
                description: [
                  `\`\`\``,
                  `‚úÖ  DEPLOYMENT SUCCESSFUL`,
                  `\`\`\``,
                  ``,
                  `> üì¶ **Project:** ${repoFullName}`,
                  `> üåç **Environment:** \`${deploy.environment}\``,
                  `> üïê **Waktu:** ${timestamp()}`,
                ].join("\n"),
                fields: [
                  {
                    name: "üîó Live Preview",
                    value: `**[Buka Aplikasi ‚Üí](${status.target_url})**`,
                    inline: false
                  }
                ],
                thumbnail: { url: "https://assets.vercel.com/image/upload/q_auto/front/favicon/vercel/180x180.png" },
                footer: {
                  text: `Triggered by ${sender.login}`,
                  icon_url: sender?.avatar_url
                },
                timestamp: new Date().toISOString()
              };

              // Send
              const payload = {
                username: "ScoutLeads Bot",
                avatar_url: ownerAvatar,
                content: "## üéâ Deployment Baru!",
                embeds: [embed]
              };

              await sendToDiscord(payload);

            } else if (context.eventName === 'push') {
              const commits = context.payload.commits || [];
              const headCommit = context.payload.head_commit;
              if (!headCommit) { console.log("No commit data, skipping."); return; }

              const branch = branchName(context.ref);
              const totalCommits = commits.length;
              const isMulti = totalCommits > 1;
              const isForced = context.payload.forced;

              // File change stats
              const allAdded = new Set();
              const allModified = new Set();
              const allRemoved = new Set();
              commits.forEach(c => {
                (c.added || []).forEach(f => allAdded.add(f));
                (c.modified || []).forEach(f => allModified.add(f));
                (c.removed || []).forEach(f => allRemoved.add(f));
              });

              // Commit list with better formatting
              const commitList = commits.slice(0, 6).map(c => {
                const hash = c.id.substring(0, 7);
                const msg = truncate(c.message.split('\n')[0], 45);
                return `[\`${hash}\`](${c.url}) ${msg}`;
              }).join("\n");
              const overflow = totalCommits > 6 ? `\n*...dan ${totalCommits - 6} commit lainnya*` : "";

              const embed = {
                color: isForced ? Colors.warning : Colors.info,
                author: {
                  name: `ScoutLeads`,
                  url: repoUrl,
                  icon_url: ownerAvatar
                },
                title: `${isForced ? "‚ö†Ô∏è Force Push" : "üöÄ Push Baru"} ke \`${branch}\``,
                url: isMulti ? context.payload.compare : headCommit.url,
                thumbnail: { url: sender?.avatar_url },
                description: [
                  `\`\`\``,
                  `${isForced ? "‚ö†Ô∏è  FORCE PUSH" : "üìù  CODE UPDATE"} ‚Äî ${totalCommits} commit${isMulti ? "s" : ""}`,
                  `\`\`\``,
                  ``,
                  `> üë§ **Pusher:** [${headCommit.author.name}](https://github.com/${headCommit.author.username || sender?.login})`,
                  `> üåø **Branch:** \`${branch}\``,
                  `> üïê **Waktu:** ${timestamp()}`,
                  ``,
                  `**üìã Commits:**`,
                  commitList + overflow,
                ].join("\n"),
                fields: [
                  {
                    name: "üìä File Changes",
                    value: [
                      `\`+${allAdded.size}\` added`,
                      `\`~${allModified.size}\` modified`,
                      `\`-${allRemoved.size}\` removed`,
                    ].join("  ‚Ä¢  "),
                    inline: false
                  },
                  {
                    name: "üîó Quick Links",
                    value: `[View Diff](${context.payload.compare}) ‚Ä¢ [Branch](${repoUrl}/tree/${branch}) ‚Ä¢ [Repo](${repoUrl})`,
                    inline: false
                  }
                ],
                footer: {
                  text: `${repoFullName} ‚Ä¢ Triggered by ${sender.login}`,
                  icon_url: sender?.avatar_url
                },
                timestamp: new Date().toISOString()
              };

              const payload = {
                username: "ScoutLeads Bot",
                avatar_url: ownerAvatar,
                embeds: [embed]
              };

              await sendToDiscord(payload);

            } else {
              console.log("Unhandled event type:", context.eventName);
              return;
            }

            // --- Send to Discord with retry ---
            async function sendToDiscord(payload) {
              const maxRetries = 3;
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  const response = await fetch(process.env.DISCORD_WEBHOOK_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                  });

                  if (response.ok) {
                    console.log(`‚úÖ Discord notification sent (attempt ${attempt})`);
                    return;
                  }

                  if (response.status === 429) {
                    const retryAfter = response.headers.get("retry-after");
                    const waitMs = retryAfter ? parseInt(retryAfter) * 1000 : 5000;
                    core.warning(`Rate limited. Retrying in ${waitMs}ms...`);
                    await new Promise(r => setTimeout(r, waitMs));
                    continue;
                  }

                  const errorText = await response.text();
                  core.warning(`Discord API error (${response.status}): ${errorText}`);

                  if (attempt === maxRetries) {
                    core.setFailed(`Failed to send Discord notification after ${maxRetries} attempts.`);
                  }
                } catch (err) {
                  core.warning(`Attempt ${attempt} failed: ${err.message}`);
                  if (attempt === maxRetries) {
                    core.setFailed(`Network error after ${maxRetries} attempts: ${err.message}`);
                  }
                  await new Promise(r => setTimeout(r, 2000 * attempt));
                }
              }
            }